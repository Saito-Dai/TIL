インターフェースと継承の違い

---

````markdown
# 🧩 インターフェースと基底クラスの違いまとめ（C#）

## 🔹 概要比較

| 項目 | インターフェース (`interface`) | 基底クラス＋派生クラス (`class` 継承) |
|------|----------------------------------|----------------------------------|
| **目的** | 「できること（契約）」を定義する | 「共通のふるまい・状態（実装）」を継承する |
| **持てるもの** | メソッド名・プロパティなど**宣言のみ**（実装なし） | フィールド、コンストラクタ、メソッドの**実装あり** |
| **継承の数** | 複数実装できる（多重実装可） | 1つしか継承できない（単一継承） |
| **使いどころ** | 異なる系統でも共通の操作をしたい時 | 同系統の共通処理をまとめたい時 |
| **キーワード** | 抽象化・契約・共通操作 | 継承・再利用・拡張 |

---

## 🔹 例①：インターフェースによる共通操作の統一

> 「**異なる種類のもの**を**同じ操作**で扱いたい」

```csharp
public interface IPlayable {
    void Play();
}

public class CDPlayer : IPlayable {
    public void Play() => Console.WriteLine("CDを再生中...");
}

public class MP3Player : IPlayable {
    public void Play() => Console.WriteLine("MP3を再生中...");
}

List<IPlayable> players = new List<IPlayable> {
    new CDPlayer(),
    new MP3Player()
};

foreach (var p in players)
    p.Play();
````

✅ **ポイント**

* `CDPlayer` と `MP3Player` は別系統だが「再生できる」という共通点で統一。
* **同じ型（IPlayable）で扱える**＝デカップリング。
* 各クラスの内部実装は自由。

---

## 🔹 例②：基底クラスによる共通動作の再利用

> 「**同系統のクラス**で**共通処理**をまとめたい」

```csharp
public class Enemy {
    public int HP { get; set; } = 100;

    public virtual void Attack() {
        Console.WriteLine("敵が攻撃した！");
    }
}

public class Boss : Enemy {
    public override void Attack() {
        Console.WriteLine("ボスが強力な攻撃をした！");
    }
}

Enemy e1 = new Enemy();
Enemy e2 = new Boss();

e1.Attack(); // 敵が攻撃した！
e2.Attack(); // ボスが強力な攻撃をした！
```

✅ **ポイント**

* `Enemy` の機能（HP・基本攻撃）を `Boss` が引き継ぐ。
* **同系統のクラス設計**に向いている。
* コードの重複を減らせる（再利用）。

---

## 🔹 使い分けの基準

| 目的                  | 適する手法        | 理由             |
| ------------------- | ------------ | -------------- |
| 共通の動作を再利用したい        | **基底クラス**    | 親の実装を引き継げる     |
| 異なる種類を同じ操作で扱いたい     | **インターフェース** | 抽象的な共通契約を定義できる |
| すでに継承していて別の機能も持たせたい | **インターフェース** | 複数同時に実装できる     |

---

## 🔹 両方を組み合わせる実践例

```csharp
public interface IDamageable {
    void TakeDamage(int amount);
}

public abstract class Character : IDamageable {
    public int HP { get; protected set; } = 100;

    public virtual void TakeDamage(int amount) {
        HP -= amount;
        Console.WriteLine($"ダメージを受けた！ 残りHP:{HP}");
    }

    public abstract void Attack();
}

public class Player : Character {
    public override void Attack() => Console.WriteLine("プレイヤーの攻撃！");
}

public class Enemy : Character {
    public override void Attack() => Console.WriteLine("敵の攻撃！");
}
```

✅ **ポイント**

* 共通の機能（HPや基本動作）は `Character` にまとめる。
* 共通の契約（ダメージを受ける仕組み）は `IDamageable` で表す。
* 現実的な設計では **両方を組み合わせるのが最も柔軟**。

---

## 🔸 まとめ

| 観点     | インターフェース       | 基底クラス        |
| ------ | -------------- | ------------ |
| 定義するもの | 契約（仕様）         | 共通処理         |
| 実装の有無  | なし             | あり           |
| 継承数    | 複数可            | 1つのみ         |
| 主な目的   | 異なる系統で共通の操作を統一 | 同系統の共通機能を再利用 |
| 関係性    | 実装契約           | 継承・拡張        |

---

> 🧠 **結論：**
>
> * 「共通の行動を**まとめて使いたい**」→ **基底クラス**
> * 「共通の契約を**守らせたい**」→ **インターフェース**
> * 実際の設計では **両方を併用してデカップリングを実現**するのが理想。


